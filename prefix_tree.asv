classdef Prefix_tree
    
    properties
        
        root_nodes = [];
        training_input = [];
        
    end
    
    methods
    
        % get prefixes from input
        
        function [prefix] = parse(obj, midi_input)

            % error checking stage wants only integer values between 0 and 127,
            % with at least two values,
            % and needs m to be a column vector

            % input 'm' for MIDI is MIDI pitch values already parsed from MIDI data

            % output 'p' for prefixes is a multi-dimensional cell array

            prefix = [];
            overall = length(obj.training_input);

            if size(midi_input,2) > size(midi_input,1)
                midi_input = midi_input';
            end

            for i = length(midi_input)-1:-1:1
    
                contin_indices = ones(i,1) * i + 1 + overall;
                prefix = [midi_input(i:-1:1),contin_indices];

                new_nodes(length(prefix),1) = Node;
                for j = length(prefix):-1:1
                    new_nodes(j).note_value = prefix(j,1);
                    new_nodes(j).add_contin(prefix(j,2));
                    if j < length(prefix)
                       new_nodes(j).add_child(new_nodes(j+1));
                    end
                end
                
                add_input(new_nodes(1));
            end
        end
        
        % add input to tree
        
        function [] = add_input(obj, root_input)
            
            node_list = [];
            cur_nodes = obj.root_nodes;
            cur_input = root_input;
            i = 0;
            
            while cur_input.has_children
                i = i + 1;
                for j = 1:length(cur_nodes)
                    
                    if cur_nodes(j).is_equal(cur_input)
                        node_list(i) = cur_nodes(j);
                        cur_nodes = cur_nodes(j).children;
                        break;
                    end
                   
                    if j == length(cur_nodes)
                        % add rest of input as chain of nodes
                        if ~isempty(node_list)
                            node_list(end).add_child(cur_input);
                        else
                            obj.root_nodes = [obj.root_nodes, cur_input];
                        end
                    end
                end
                
                cur_input = cur_input.children(1);
            end
            
            for j = 1:length(cur_nodes)
                    
                if cur_nodes(j).is_equal(cur_input)
                    node_list(i) = cur_nodes(j);
                    cur_nodes = cur_nodes(j).children;
                    break;                        
                end

                if j == length(cur_nodes)
                    % add rest of input as chain of nodes
                    if ~isempty(node_list)
                        node_list(end).add_child(cur_input);
                    else
                        obj.root_nodes = [obj.root_nodes, cur_input];
                    end
                end
            end
            % handle case for cur_input is length 1
            
            % add continuation indices to node_list
            
            
            
        end
        
    end
    
end